<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ElementContainer.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gsvg</a> &gt; <a href="index.source.html" class="el_package">se.alipsa.groovy.svg</a> &gt; <span class="el_source">ElementContainer.groovy</span></div><h1>ElementContainer.groovy</h1><pre class="source lang-java linenums">package se.alipsa.groovy.svg

import groovy.transform.CompileStatic

/**
 * Trait that stores child elements and provides selection helpers.
 */
@CompileStatic
trait ElementContainer {

  private List&lt;SvgElement&lt;? extends SvgElement&gt;&gt; children = []

  /**
   * Returns the children value.
   *
   * @return the children value
   */
  List&lt;SvgElement&lt;? extends SvgElement&gt;&gt; getChildren() {
    children
  }

  /**
   * Adds a child element to this container.
   *
   * @param svgElement the SVG element
   * @return the added element
   */
  &lt;E extends SvgElement&gt; E add(E svgElement) {
    children.add(svgElement)
    svgElement
  }

  /**
   * Returns child element(s) for the provided selector.
   *
   * @param index the index
   * @return the result
   */
  SvgElement getAt(Integer index) {
    children[index]
  }

  /**
   * Returns child element(s) for the provided selector.
   *
   * @param name the name of the element
   * @return the result
   */
  List&lt;SvgElement&gt; getAt(String name) {
<span class="fc" id="L50">    children.stream().filter (e -&gt; e.name == name).findAll()</span>
  }

  /**
   * Returns child element(s) for the provided selector.
   *
   * @param clazz the CSS class
   * @return the result
   */
  List&lt;SvgElement&gt; getAt(Class&lt;? extends SvgElement&gt; clazz) {
<span class="fc" id="L60">    children.stream().filter (e -&gt; e.class == clazz).findAll()</span>
  }

  // ==================== ENHANCED SELECTION METHODS ====================

  /**
   * Filter child elements using a predicate closure.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def largeRects = svg.filter { it instanceof Rect &amp;&amp; it.getWidth() as int &gt; 100 }
   * def redElements = svg.filter { it.getFill() == 'red' }
   * &lt;/pre&gt;
   *
   * @param predicate a closure that returns true for elements to include
   * @return a list of matching elements
   */
  List&lt;SvgElement&gt; filter(Closure&lt;Boolean&gt; predicate) {
    children.findAll(predicate)
  }

  /**
   * Find all child elements of a specific type, optionally filtered by a predicate.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def allCircles = svg.findAll(Circle)
   * def largeCircles = svg.findAll(Circle) { it.getR() as int &gt; 50 }
   * &lt;/pre&gt;
   *
   * @param clazz the element type to find
   * @param predicate optional predicate closure to filter results
   * @return a list of matching elements
   */
  &lt;T extends SvgElement&gt; List&lt;T&gt; findAll(Class&lt;T&gt; clazz, Closure&lt;Boolean&gt; predicate = null) {
<span class="fc" id="L93">    List&lt;T&gt; results = children.findAll { it.class == clazz } as List&lt;T&gt;</span>
    predicate ? results.findAll(predicate) : results
  }

  /**
   * Find the first child element matching a predicate.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def firstRed = svg.findFirst { it.getFill() == 'red' }
   * def logoElement = svg.findFirst { it.getId() == 'logo' }
   * &lt;/pre&gt;
   *
   * @param predicate a closure that returns true for the element to find
   * @return the first matching element, or null if none found
   */
  SvgElement findFirst(Closure&lt;Boolean&gt; predicate) {
    children.find(predicate)
  }

  /**
   * Find the first child element of a specific type.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def firstCircle = svg.findFirst(Circle)
   * &lt;/pre&gt;
   *
   * @param clazz the element type to find
   * @return the first matching element, or null if none found
   */
  &lt;T extends SvgElement&gt; T findFirst(Class&lt;T&gt; clazz) {
<span class="fc" id="L123">    children.find { it.class == clazz } as T</span>
  }

  /**
   * Get all descendant elements (recursive search through all children and their children).
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def allElements = svg.descendants()
   * def allCircles = svg.descendants(Circle)
   * &lt;/pre&gt;
   *
   * @param clazz optional class filter, if null returns all descendants
   * @return a list of all descendant elements (or only those of the specified type)
   */
  &lt;T extends SvgElement&gt; List&lt;T&gt; descendants(Class&lt;T&gt; clazz = null) {
    List&lt;T&gt; results = []
    collectDescendants(children, clazz, results)
    results
  }

  /**
   * Helper method for recursive descendant collection
   */
  private &lt;T extends SvgElement&gt; void collectDescendants(
      List&lt;SvgElement&lt;? extends SvgElement&gt;&gt; elements,
      Class&lt;T&gt; clazz,
      List&lt;T&gt; results) {
    for (SvgElement element : elements) {
      // Add to results if it matches the type filter (or no filter)
      if (clazz == null || element.class == clazz) {
        results.add(element as T)
      }

      // Recurse into child containers
      if (element instanceof ElementContainer) {
        collectDescendants(((ElementContainer) element).children, clazz, results)
      }
    }
  }

  /**
   * Transform XPath queries to be namespace-aware for SVG elements.
   * Converts simple element queries like //circle to //*[local-name()='circle']
   * to work with namespaced SVG elements.
   *
   * @param xpathQuery the original XPath query
   * @return the transformed, namespace-aware query
   */
  private String transformXPathForNamespace(String xpathQuery) {
    // Don't transform if already using local-name() or namespace prefixes
    if (xpathQuery.contains('local-name()') || xpathQuery.contains(':')) {
      return xpathQuery
    }

    // Transform //elementName to //*[local-name()='elementName']
    String result = xpathQuery.replaceAll(
      /\/\/([\w-]+)(?=[\/@\[]|$)/,
      &quot;//*[local-name()='\$1']&quot;
    )

    // Transform /elementName to /*[local-name()='elementName']
    // This needs to run in a loop to handle paths like /svg/circle/g
    while (result =~ /(^|[\])])\/(?!\/)([\w-]+)(?=[\/@\[]|$)/) {
      result = result.replaceAll(
        /(^|[\]])\/(?!\/)([\w-]+)(?=[\/@\[]|$)/,
        '\$1/*[local-name()=\'\$2\']'
      )
    }

    return result
  }

  /**
   * Execute XPath query on the SVG DOM and return matching elements.
   * &lt;p&gt;
   * &lt;strong&gt;Namespace Handling:&lt;/strong&gt; This method automatically handles SVG namespaces
   * for simple element queries. Queries like {@code //circle} or {@code //g/rect} are
   * transparently transformed to work with namespaced SVG elements.
   * &lt;/p&gt;
   * &lt;p&gt;&lt;strong&gt;Supported Patterns:&lt;/strong&gt;&lt;/p&gt;
   * &lt;ul&gt;
   *   &lt;li&gt;Element queries: {@code //circle}, {@code /svg/rect}, {@code //g/path}&lt;/li&gt;
   *   &lt;li&gt;Attribute queries: {@code //rect[@fill=&quot;red&quot;]}, {@code //*[@id=&quot;logo&quot;]}&lt;/li&gt;
   *   &lt;li&gt;Mixed queries: {@code //g[@id=&quot;group1&quot;]/circle}&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;p&gt;
   * &lt;strong&gt;Performance Note:&lt;/strong&gt; This method builds a map of all descendants for O(1) element
   * lookups, making it O(n+m) where n is the number of XPath results and m is the total number of
   * descendants. For most use cases, this provides good performance.
   * &lt;/p&gt;
   * &lt;p&gt;
   * &lt;strong&gt;Limitations:&lt;/strong&gt; XPath numeric comparisons on attributes may not work as expected.
   * For complex queries, use filter() with predicates instead.
   * &lt;/p&gt;
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def redRects = svg.xpath('//rect[@fill=&quot;red&quot;]')
   * def allPaths = svg.xpath('//path')
   * def specificElement = svg.xpath('//*[@id=&quot;logo&quot;]')
   * def nested = svg.xpath('//g/circle')  // Finds circles inside groups
   * &lt;/pre&gt;
   *
   * @param xpathQuery the XPath query string
   * @return a list of SvgElement objects matching the query
   */
  List&lt;SvgElement&gt; xpath(String xpathQuery) {
    // Get the dom4j element from the container
    org.dom4j.Element domElement = null
    if (this instanceof SvgElement) {
      domElement = ((SvgElement) this).element
    } else {
      throw new UnsupportedOperationException(&quot;XPath queries require the container to be an SvgElement&quot;)
    }

    // Transform query to be namespace-aware and execute
    String transformedQuery = transformXPathForNamespace(xpathQuery)
    List&lt;org.dom4j.Node&gt; nodes = domElement.selectNodes(transformedQuery)

    // Build a map of dom4j elements to SvgElement wrappers for O(1) lookups
    // This avoids O(n*m) complexity by doing a single O(m) traversal upfront
    Map&lt;org.dom4j.Element, SvgElement&gt; elementMap = descendants().collectEntries {
<span class="fc" id="L244">      [(it.element): it]</span>
    } as Map&lt;org.dom4j.Element, SvgElement&gt;

    // Convert dom4j elements back to SvgElement wrappers using the map
    List&lt;SvgElement&gt; results = []
    for (org.dom4j.Node node : nodes) {
      if (node instanceof org.dom4j.Element) {
        SvgElement svgElement = elementMap.get((org.dom4j.Element) node)
        if (svgElement != null) {
          results.add(svgElement)
        }
      }
    }
    results
  }

  /**
   * Count the number of child elements matching a predicate.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def redCount = svg.count { it.getFill() == 'red' }
   * &lt;/pre&gt;
   *
   * @param predicate a closure that returns true for elements to count
   * @return the count of matching elements
   */
  int count(Closure&lt;Boolean&gt; predicate) {
    children.count(predicate) as int
  }

  /**
   * Check if any child element matches a predicate.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * if (svg.any { it instanceof Circle }) {
   *   println &quot;Contains at least one circle&quot;
   * }
   * &lt;/pre&gt;
   *
   * @param predicate a closure that returns true for matching elements
   * @return true if at least one element matches
   */
  boolean any(Closure&lt;Boolean&gt; predicate) {
    children.any(predicate)
  }

  /**
   * Check if all child elements match a predicate.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * if (svg.all { it.getFill() != null }) {
   *   println &quot;All elements have a fill color&quot;
   * }
   * &lt;/pre&gt;
   *
   * @param predicate a closure that returns true for matching elements
   * @return true if all elements match
   */
  boolean all(Closure&lt;Boolean&gt; predicate) {
    children.every(predicate)
  }

  /**
   * Collect values from child elements using a transformation closure.
   * &lt;p&gt;Example:&lt;/p&gt;
   * &lt;pre&gt;
   * def allFillColors = svg.collect { it.getFill() }
   * def allIds = svg.collect { it.getId() }
   * &lt;/pre&gt;
   *
   * @param transform a closure that transforms each element to a value
   * @return a list of collected values
   */
  &lt;R&gt; List&lt;R&gt; collect(Closure&lt;R&gt; transform) {
    children.collect(transform)
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>